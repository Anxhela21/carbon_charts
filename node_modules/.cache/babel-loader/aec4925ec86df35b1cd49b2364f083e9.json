{"ast":null,"code":"function _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n/**\n * Copyright IBM Corp. 2016, 2018\n *\n * This source code is licensed under the Apache-2.0 license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nimport { settings } from 'carbon-components';\nimport cx from 'classnames';\nimport PropTypes from 'prop-types';\nimport React, { Children, cloneElement, useEffect, useRef, useState } from 'react';\nimport { composeEventHandlers } from '../../tools/events';\nimport { getNextIndex, matches, keys } from '../../internal/keyboard';\nvar prefix = settings.prefix;\n\nfunction ContentSwitcher(_ref) {\n  var children = _ref.children,\n      customClassName = _ref.className,\n      onChange = _ref.onChange,\n      _ref$selectedIndex = _ref.selectedIndex,\n      controlledSelectedIndex = _ref$selectedIndex === void 0 ? 0 : _ref$selectedIndex,\n      rest = _objectWithoutProperties(_ref, [\"children\", \"className\", \"onChange\", \"selectedIndex\"]);\n\n  var switchRefs = [];\n  var className = cx(\"\".concat(prefix, \"--content-switcher\"), customClassName);\n  var savedOnChange = useRef(null);\n\n  var _useState = useState(controlledSelectedIndex),\n      _useState2 = _slicedToArray(_useState, 2),\n      selectedIndex = _useState2[0],\n      setSelectedIndex = _useState2[1];\n\n  var _useState3 = useState(controlledSelectedIndex),\n      _useState4 = _slicedToArray(_useState3, 2),\n      prevControlledIndex = _useState4[0],\n      setPrevControlledIndex = _useState4[1];\n\n  var _useState5 = useState(false),\n      _useState6 = _slicedToArray(_useState5, 2),\n      shouldFocus = _useState6[0],\n      setShouldFocus = _useState6[1];\n\n  if (controlledSelectedIndex !== prevControlledIndex) {\n    setSelectedIndex(controlledSelectedIndex);\n    setPrevControlledIndex(controlledSelectedIndex);\n    setShouldFocus(false);\n  } // Always keep track of the latest `onChange` prop to use in our focus effect\n  // handler\n\n\n  useEffect(function () {\n    savedOnChange.current = onChange;\n  }, [onChange]); // If our selectedIndex has changed from an event handler, meaning that\n  // `shouldFocus` is set to true, then call the saved `onChange` handler if it\n  // exists\n\n  useEffect(function () {\n    if (shouldFocus && savedOnChange.current) {\n      savedOnChange.current(selectedIndex);\n    }\n  }, [shouldFocus, selectedIndex]); // We have a couple of scenarios we want to keep track of when managing focus:\n  // 1) Don't focus the ref at the selectedIndex if its the first render, focus\n  //    should only come from a user action\n  // 2) Don't focus if selectedIndex has changed because of a change in props\n  // 3) Trigger focus if triggered by click or key down. Both of these handlers\n  //    should set `shouldFocus` to true\n\n  useEffect(function () {\n    if (!shouldFocus) {\n      return;\n    }\n\n    var ref = switchRefs[selectedIndex];\n\n    if (ref && document.activeElement !== ref) {\n      ref.focus && ref.focus();\n    }\n  }, [shouldFocus, switchRefs, selectedIndex]);\n\n  function handleItemRef(index) {\n    return function (ref) {\n      switchRefs[index] = ref;\n    };\n  }\n\n  function onClick(event, index) {\n    if (selectedIndex !== index) {\n      setSelectedIndex(index);\n\n      if (shouldFocus !== true) {\n        setShouldFocus(true);\n      }\n    }\n  }\n\n  function onKeyDown(event) {\n    if (matches(event, [keys.ArrowRight, keys.ArrowLeft])) {\n      setSelectedIndex(getNextIndex(event, selectedIndex, children.length));\n\n      if (shouldFocus !== true) {\n        setShouldFocus(true);\n      }\n    }\n  }\n\n  return React.createElement(\"div\", _extends({\n    className: className\n  }, rest), Children.map(children, function (child, index) {\n    return cloneElement(child, {\n      index: index,\n      onClick: composeEventHandlers([onClick, child.props.onClick]),\n      onKeyDown: composeEventHandlers([onKeyDown, child.props.onKeyDown]),\n      selected: index === selectedIndex,\n      ref: handleItemRef(index)\n    });\n  }));\n}\n\nContentSwitcher.propTypes = {\n  /**\n   * Pass in Switch components to be rendered in the ContentSwitcher\n   */\n  children: PropTypes.node,\n\n  /**\n   * Specify an optional className to be added to the container node\n   */\n  className: PropTypes.string,\n\n  /**\n   * Specify an `onChange` handler that is called whenever the ContentSwitcher\n   * changes which item is selected\n   */\n  onChange: PropTypes.func.isRequired,\n\n  /**\n   * Specify a selected index for the initially selected content\n   */\n  selectedIndex: PropTypes.number\n};\nexport default ContentSwitcher;","map":null,"metadata":{},"sourceType":"module"}