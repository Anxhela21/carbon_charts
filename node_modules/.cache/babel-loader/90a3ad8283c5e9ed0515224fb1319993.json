{"ast":null,"code":"import _Object$getPrototypeOf from 'babel-runtime/core-js/object/get-prototype-of';\nimport _classCallCheck from 'babel-runtime/helpers/classCallCheck';\nimport _createClass from 'babel-runtime/helpers/createClass';\nimport _possibleConstructorReturn from 'babel-runtime/helpers/possibleConstructorReturn';\nimport _inherits from 'babel-runtime/helpers/inherits';\nimport PropTypes from 'prop-types';\nimport React, { Component } from 'react';\nimport ReactDOM from 'react-dom';\nimport * as d3 from 'd3';\nimport DataTooltip from '../DataTooltip/DataTooltip';\nimport _ from 'lodash';\nvar propTypes = {\n  /**\n   * If your data set has a single series, or multiple series with all the same x values, use the data prop, and format like this: [[y1a, y1b, ... , x1], [y2a, y2b, ... , x2], ...]\n   */\n  data: PropTypes.arrayOf(PropTypes.arrayOf(PropTypes.number)),\n\n  /**\n   * If your data set has multiple series with different x values, use the datasets prop, and format like this: [[[y1a, x1a], [y2a, x2a], ...], [[y1b, x1b], [y2b, x2b], ...], ...]\n   */\n  datasets: PropTypes.arrayOf(PropTypes.arrayOf(PropTypes.arrayOf(PropTypes.number))),\n\n  /**\n   * If your data set has multiple series, the seriesLabels array should contain strings labeling your series in the same order that your series appear in either data or datasets props.\n   */\n  seriesLabels: PropTypes.arrayOf(PropTypes.string),\n  timeFormatLocale: PropTypes.shape({\n    dateTime: PropTypes.string,\n    date: PropTypes.string,\n    time: PropTypes.string,\n    periods: PropTypes.arrayOf(PropTypes.string),\n    days: PropTypes.arrayOf(PropTypes.string),\n    shortDays: PropTypes.arrayOf(PropTypes.string),\n    months: PropTypes.arrayOf(PropTypes.string),\n    shortMonths: PropTypes.arrayOf(PropTypes.string)\n  }),\n  height: PropTypes.number,\n  width: PropTypes.number,\n  id: PropTypes.string,\n  containerId: PropTypes.string,\n  margin: PropTypes.object,\n  labelOffsetX: PropTypes.number,\n  labelOffsetY: PropTypes.number,\n  axisOffset: PropTypes.number,\n  timeFormat: PropTypes.string,\n  xAxisLabel: PropTypes.string,\n  yAxisLabel: PropTypes.string,\n  onHover: PropTypes.func,\n  onMouseOut: PropTypes.func,\n  emptyText: PropTypes.string,\n  isUTC: PropTypes.bool,\n  color: PropTypes.array,\n  drawLine: PropTypes.bool,\n  animateAxes: PropTypes.bool,\n  showTooltip: PropTypes.bool,\n  showLegend: PropTypes.bool,\n\n  /**\n   * Set this prop to false to prevent x values from being converted to time.\n   */\n  isXTime: PropTypes.bool\n};\nvar defaultProps = {\n  data: [],\n  datasets: [],\n  seriesLabels: [],\n  height: 300,\n  width: 800,\n  id: 'container',\n  containerId: 'graph-container',\n  margin: {\n    top: 30,\n    right: 20,\n    bottom: 70,\n    left: 65\n  },\n  labelOffsetX: 65,\n  labelOffsetY: 55,\n  axisOffset: 16,\n  timeFormat: '%I:%M:%S',\n  xAxisLabel: 'X Axis',\n  yAxisLabel: 'Y Axis',\n  onHover: function onHover() {},\n  onMouseOut: function onMouseOut() {},\n  emptyText: 'There is currently no data available for the parameters selected. Please try a different combination.',\n  isUTC: false,\n  color: ['#00a68f', '#3b1a40', '#473793', '#3c6df0', '#56D2BB'],\n  drawLine: true,\n  animateAxes: true,\n  showTooltip: true,\n  showLegend: false,\n  isXTime: true\n};\n\nvar LineGraph = function (_Component) {\n  _inherits(LineGraph, _Component);\n\n  function LineGraph() {\n    _classCallCheck(this, LineGraph);\n\n    return _possibleConstructorReturn(this, (LineGraph.__proto__ || _Object$getPrototypeOf(LineGraph)).apply(this, arguments));\n  }\n\n  _createClass(LineGraph, [{\n    key: 'componentDidMount',\n    value: function componentDidMount() {\n      var _props = this.props,\n          data = _props.data,\n          datasets = _props.datasets,\n          width = _props.width,\n          height = _props.height,\n          margin = _props.margin,\n          containerId = _props.containerId,\n          emptyText = _props.emptyText,\n          showLegend = _props.showLegend,\n          seriesLabels = _props.seriesLabels;\n\n      if (data.length > 0) {\n        this.totalLines = data[0].length - 1;\n      } else if (datasets.length > 0) {\n        this.totalLines = datasets.length;\n      }\n\n      this.emptyContainer = d3.select('#' + containerId + ' .bx--line-graph-empty-text').text(emptyText).style('position', 'absolute').style('top', '50%').style('left', '50%').style('text-align', 'center').style('transform', 'translate(-50%, -50%)');\n      this.svg = d3.select('#' + containerId + ' svg').attr('class', 'bx--graph').attr('width', width).attr('height', height).append('g').attr('class', 'bx--group-container').attr('transform', 'translate(' + margin.left + ', ' + margin.top + ')');\n      this.width = width - (margin.left + margin.right + (showLegend && seriesLabels.length > 0 ? 30 + _.max(seriesLabels.map(function (l) {\n        return l.length;\n      })) * 8 : 0));\n      this.height = height - (margin.top + margin.bottom);\n      this.initialRender();\n    }\n  }, {\n    key: 'componentWillReceiveProps',\n    value: function componentWillReceiveProps(nextProps) {\n      if (nextProps.height != this.props.height || nextProps.width != this.props.width) {\n        this.resize(nextProps.height, nextProps.width);\n      }\n    }\n  }, {\n    key: 'shouldComponentUpdate',\n    value: function shouldComponentUpdate(nextProps) {\n      return this.props.data !== nextProps.data || this.props.datasets !== nextProps.datasets;\n    }\n  }, {\n    key: 'componentWillUpdate',\n    value: function componentWillUpdate(nextProps) {\n      if (this.x) {\n        var data = nextProps.data.length > 0 ? nextProps.data : _.flatten(nextProps.datasets);\n        this.x.domain(d3.extent(data, function (d) {\n          return d[d.length - 1];\n        }));\n        this.y.domain([0, d3.max(data, function (d) {\n          return d3.max(d.slice(0, d.length - 1));\n        })]);\n        this.updateEmptyState(nextProps.data.length > 0 ? nextProps.data : nextProps.datasets);\n        this.updateData(nextProps);\n      }\n    }\n  }, {\n    key: 'componentDidUpdate',\n    value: function componentDidUpdate(prevProps) {\n      var _props2 = this.props,\n          showLegend = _props2.showLegend,\n          seriesLabels = _props2.seriesLabels; // If seriesLabels change, remove legend and re-render\n\n      if (showLegend && seriesLabels.length !== prevProps.seriesLabels.length) {\n        this.svg.selectAll('.legend').remove();\n        this.renderLegend();\n      }\n    }\n  }, {\n    key: 'updateEmptyState',\n    value: function updateEmptyState(data) {\n      if (data[0] ? !Array.isArray(data[0][0]) && data.length < 2 || Array.isArray(data[0][0]) && _.max(data.map(function (d) {\n        return d.length;\n      })) < 2 : true) {\n        this.svg.style('opacity', '.3');\n        this.emptyContainer.style('display', 'inline-block');\n      } else {\n        this.svg.style('opacity', '1');\n        this.emptyContainer.style('display', 'none');\n      }\n    }\n  }, {\n    key: 'updateData',\n    value: function updateData(nextProps) {\n      var data = nextProps.data,\n          datasets = nextProps.datasets,\n          axisOffset = nextProps.axisOffset,\n          xAxisLabel = nextProps.xAxisLabel,\n          yAxisLabel = nextProps.yAxisLabel,\n          animateAxes = nextProps.animateAxes;\n\n      for (var i = 0; i < this.totalLines; i++) {\n        this.svg.selectAll('g[data-line=\"' + i + '\"]').remove();\n      }\n\n      if (data.length > 0) {\n        this.totalLines = data[0].length - 1;\n      } else if (datasets.length > 0) {\n        this.totalLines = datasets.length;\n      }\n\n      if (animateAxes) {\n        this.svg.select('.bx--axis--x').transition().call(this.xAxis).selectAll('.bx--axis--x .tick text').attr('y', axisOffset).style('text-anchor', 'end').attr('transform', 'rotate(-65)');\n        this.svg.select('.bx--axis--y').transition().call(this.yAxis).selectAll('text').attr('x', -axisOffset);\n      } else {\n        this.svg.select('.bx--axis--x').call(this.xAxis).selectAll('.bx--axis--x .tick text').attr('y', axisOffset).style('text-anchor', 'end').attr('transform', 'rotate(-65)');\n        this.svg.select('.bx--axis--y').call(this.yAxis).selectAll('text').attr('x', -axisOffset);\n      }\n\n      this.svg.select('.bx--axis--y .bx--graph-label').text(yAxisLabel);\n      this.svg.select('.bx--axis--x .bx--graph-label').text(xAxisLabel);\n      this.updateStyles();\n    }\n  }, {\n    key: 'updateStyles',\n    value: function updateStyles() {\n      this.svg.selectAll('.bx--axis--y path').style('display', 'none');\n      this.svg.selectAll('.bx--axis path').attr('stroke', '#5A6872');\n      this.svg.selectAll('.tick line').attr('stroke', '#5A6872');\n      this.svg.selectAll('.tick text').attr('fill', '#5A6872');\n    }\n  }, {\n    key: 'resize',\n    value: function resize(height, width) {\n      var _props3 = this.props,\n          margin = _props3.margin,\n          containerId = _props3.containerId,\n          showLegend = _props3.showLegend,\n          seriesLabels = _props3.seriesLabels;\n      this.height = height - (margin.top + margin.bottom);\n      this.width = width - (margin.left + margin.right + (showLegend && seriesLabels.length > 0 ? 30 + _.max(seriesLabels.map(function (l) {\n        return l.length;\n      })) * 8 : 0));\n      this.svg.selectAll('*').remove();\n      this.svg = d3.select('#' + containerId + ' svg').attr('class', 'bx--graph').attr('width', width).attr('height', height).append('g').attr('class', 'bx--group-container').attr('transform', 'translate(' + margin.left + ', ' + margin.top + ')');\n      this.initialRender();\n    }\n  }, {\n    key: 'initialRender',\n    value: function initialRender() {\n      var _this2 = this;\n\n      var _props4 = this.props,\n          data = _props4.data,\n          datasets = _props4.datasets,\n          timeFormat = _props4.timeFormat,\n          isUTC = _props4.isUTC,\n          isXTime = _props4.isXTime,\n          showLegend = _props4.showLegend,\n          seriesLabels = _props4.seriesLabels,\n          timeFormatLocale = _props4.timeFormatLocale;\n      this.updateEmptyState(data.length > 0 ? data : datasets);\n      var flatData = data.length > 0 ? data : _.flatten(datasets);\n\n      if (isUTC) {\n        this.x = d3.scaleUtc().range([0, this.width]).domain(d3.extent(flatData, function (d) {\n          return d[d.length - 1];\n        }));\n      } else if (isXTime) {\n        this.x = d3.scaleTime().range([0, this.width]).domain(d3.extent(flatData, function (d) {\n          return d[d.length - 1];\n        }));\n      } else {\n        this.x = d3.scaleLinear().range([0, this.width]).domain(d3.extent(flatData, function (d) {\n          return d[d.length - 1];\n        }));\n      }\n\n      this.y = d3.scaleLinear().range([this.height, 0]).domain([0, d3.max(flatData, function (d) {\n        return d3.max(d.slice(0, d.length - 1));\n      }) || 10]);\n      this.line = d3.line().x(function (d) {\n        return _this2.x(d[d.length - 1]);\n      }).y(function (d) {\n        return _this2.y(d[_this2.count]);\n      }).defined(function (d) {\n        return !isNaN(d[_this2.count]);\n      });\n\n      if (timeFormatLocale) {\n        d3.timeFormatDefaultLocale(timeFormatLocale);\n      }\n\n      var tickFormat = isUTC ? d3.utcFormat(timeFormat) : d3.timeFormat(timeFormat);\n      this.xAxis = d3.axisBottom().scale(this.x).tickSize(0).tickFormat(isXTime ? tickFormat : null);\n      this.yAxis = d3.axisLeft().ticks(4).tickSize(-this.width).scale(this.y.nice());\n      this.renderAxes();\n      this.renderLabels();\n      this.renderOverlay();\n\n      if (this.x) {\n        this.renderLine();\n      }\n\n      if (showLegend && seriesLabels.length > 0) {\n        this.renderLegend();\n      }\n    }\n  }, {\n    key: 'renderAxes',\n    value: function renderAxes() {\n      var axisOffset = this.props.axisOffset;\n      this.svg.append('g').attr('class', 'bx--axis bx--axis--y').attr('stroke-dasharray', '4').call(this.yAxis).selectAll('text').attr('x', -axisOffset);\n      this.svg.append('g').attr('class', 'bx--axis bx--axis--x').attr('transform', 'translate(0, ' + this.height + ')').call(this.xAxis).selectAll('text').attr('y', axisOffset).style('text-anchor', 'end').attr('transform', 'rotate(-65)');\n      this.updateStyles();\n    }\n  }, {\n    key: 'renderLabels',\n    value: function renderLabels() {\n      var _props5 = this.props,\n          labelOffsetY = _props5.labelOffsetY,\n          labelOffsetX = _props5.labelOffsetX,\n          xAxisLabel = _props5.xAxisLabel,\n          yAxisLabel = _props5.yAxisLabel;\n      this.svg.select('.bx--axis--y').append('text').text('' + yAxisLabel).attr('class', 'bx--graph-label').attr('transform', 'translate(' + -labelOffsetY + ', ' + this.height / 2 + ') rotate(-90)');\n      this.svg.select('.bx--axis--x').append('text').text('' + xAxisLabel).attr('class', 'bx--graph-label').attr('transform', 'translate(' + this.width / 2 + ', ' + labelOffsetX + ')');\n      this.svg.selectAll('.bx--graph-label').attr('font-size', '10').attr('font-weight', '700').attr('fill', '#5A6872').attr('text-anchor', 'middle');\n    }\n  }, {\n    key: 'renderLine',\n    value: function renderLine() {\n      var _props6 = this.props,\n          data = _props6.data,\n          datasets = _props6.datasets,\n          drawLine = _props6.drawLine;\n      var color = d3.scaleOrdinal(this.props.color);\n      var hasData = data.length > 0;\n      var numLines = hasData ? data[0].length - 1 : datasets.length;\n      this.count = 0;\n\n      if (hasData || _.max(datasets.map(function (d) {\n        return d.length;\n      })) > 0) {\n        for (var i = 0; i < numLines; i++) {\n          var path = this.svg.append('g').attr('data-line', i).datum(hasData ? data : datasets[i]).append('path').attr('class', 'bx--line').attr('stroke', color(i)).attr('stroke-width', 2).attr('fill', 'none').attr('pointer-events', 'none').attr('d', this.line);\n          var totalLength = path.node().getTotalLength();\n\n          if (drawLine) {\n            path.attr('stroke-dasharray', 0 + ' ' + totalLength).transition().ease(d3.easeSin).duration(1000).attr('stroke-dasharray', totalLength + ' ' + 0);\n          } else {\n            path.attr('stroke-dasharray', 0 + ' ' + totalLength).attr('stroke-dasharray', totalLength + ' ' + 0);\n          }\n\n          this.count += hasData ? 1 : 0;\n        }\n      }\n    }\n  }, {\n    key: 'renderOverlay',\n    value: function renderOverlay() {\n      var _this3 = this;\n\n      this.svg.append('rect').attr('width', this.width).attr('height', this.height).attr('class', 'overlay').style('fill', 'none').style('pointer-events', 'all').on('mousemove', function () {\n        _this3.onMouseMove();\n      }).on('mouseout', function () {\n        _this3.onMouseOut();\n      });\n    }\n  }, {\n    key: 'renderLegend',\n    value: function renderLegend() {\n      var _this4 = this;\n\n      var seriesLabels = this.props.seriesLabels;\n      var legendRectSize = 18;\n      var legendSpacing = 4;\n      var legend = this.svg.selectAll('.legend').data(seriesLabels).enter().append('g').attr('class', 'legend').attr('transform', function (d, i) {\n        var h = legendRectSize + legendSpacing;\n        var offset = h * seriesLabels.length / 2;\n        var horz = _this4.width + 10;\n        var vert = i * h - offset + 50;\n        return 'translate(' + horz + ',' + vert + ')';\n      });\n      legend.append('rect').attr('width', legendRectSize).attr('height', legendRectSize).style('fill', function (d, i) {\n        return _this4.props.color[i];\n      }).style('stroke', function (d, i) {\n        return _this4.props.color[i];\n      });\n      legend.append('text').attr('x', legendRectSize + legendSpacing).attr('y', legendRectSize - legendSpacing).text(function (d, i) {\n        return seriesLabels[i];\n      });\n    }\n  }, {\n    key: 'onMouseOut',\n    value: function onMouseOut() {\n      if (this.props.data.length > 2 || _.max(this.props.datasets.map(function (d) {\n        return d.length;\n      })) > 2) {\n        this.props.onMouseOut();\n\n        if (this.tooltipId) {\n          ReactDOM.unmountComponentAtNode(this.tooltipId);\n        }\n      }\n    }\n  }, {\n    key: 'onMouseMove',\n    value: function onMouseMove() {\n      var _this5 = this;\n\n      if (!this.id) return null;\n      var _props7 = this.props,\n          margin = _props7.margin,\n          data = _props7.data,\n          datasets = _props7.datasets,\n          showTooltip = _props7.showTooltip,\n          timeFormat = _props7.timeFormat,\n          color = _props7.color,\n          height = _props7.height,\n          labelOffsetX = _props7.labelOffsetX,\n          isXTime = _props7.isXTime,\n          seriesLabels = _props7.seriesLabels;\n\n      if (data.length > 2 || _.max(datasets.map(function (d) {\n        return d.length;\n      })) > 2) {\n        var bisectDate = d3.bisector(function (d) {\n          return d[d.length - 1];\n        }).right;\n        var mouse = d3.mouse(this.id)[0] - margin.left;\n        var timestamp = this.x.invert(mouse);\n        var d = void 0,\n            mouseData = void 0,\n            tooltipHeading = void 0,\n            tooltipData = void 0;\n\n        if (data.length > 0) {\n          var index = bisectDate(data, timestamp);\n          var d0 = data[index - 1];\n          var d1 = data[index];\n\n          if (d0 && d1) {\n            d = timestamp - d0[d0.length - 1] > d1[d1.length - 1] - timestamp ? d1 : d0;\n            mouseData = {\n              data: d,\n              pageX: d3.event.pageX,\n              pageY: d3.event.pageY,\n              graphX: this.x(d[d.length - 1]),\n              graphY: this.y(d[0]),\n              graphYArray: d.slice(0, -1).map(this.y)\n            };\n            tooltipData = _.dropRight(d).map(function (p, i) {\n              return {\n                data: _.round(p, 2),\n                label: seriesLabels[i],\n                color: color[i]\n              };\n            });\n            tooltipHeading = d.length > 2 ? isXTime ? d3.timeFormat(timeFormat)(d[d.length - 1]) : d[d.length - 1] : null;\n          }\n        } else {\n          var mouseX = this.x(timestamp);\n          var mouseY = d3.mouse(this.id)[1] - margin.top;\n          var distances = [];\n          d = _.sortBy(_.flatten(datasets), function (a) {\n            var aDist = Math.pow(mouseX - _this5.x(a[a.length - 1]), 2) + Math.pow(mouseY - _this5.y(a[0]), 2);\n            distances.push({\n              a: a,\n              aDist: aDist\n            });\n            return aDist;\n          })[0];\n          var i = datasets.findIndex(function (set) {\n            return set.includes(d);\n          });\n          mouseData = {\n            data: d,\n            pageX: d3.event.pageX,\n            pageY: d3.event.pageY,\n            graphX: this.x(d[d.length - 1]),\n            graphY: this.y(d[0]),\n            graphYArray: d.slice(0, -1).map(this.y)\n          };\n          var xVal = isXTime ? d3.timeFormat(timeFormat)(d[d.length - 1]) : d[d.length - 1];\n          tooltipHeading = d.length > 2 ? xVal : null;\n          tooltipData = _.dropRight(d).map(function (p) {\n            return {\n              data: _.round(p, 2),\n              label: tooltipHeading ? seriesLabels[i] : xVal,\n              color: color[i]\n            };\n          });\n        }\n\n        this.props.onHover(mouseData);\n\n        if (showTooltip && tooltipData && tooltipData.length > 0) {\n          ReactDOM.render(React.createElement(DataTooltip, {\n            heading: tooltipHeading,\n            data: tooltipData\n          }), this.tooltipId);\n          var tooltipSize = d3.select(this.tooltipId.children[0]).node().getBoundingClientRect();\n          var offset = -tooltipSize.width / 2;\n          d3.select(this.tooltipId).style('position', 'relative').style('left', mouseData.graphX + labelOffsetX + offset + 'px').style('top', this.y(_.max(_.dropRight(d))) - height - tooltipSize.height + 10 + 'px');\n        }\n      }\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      var _this6 = this;\n\n      var _props8 = this.props,\n          id = _props8.id,\n          containerId = _props8.containerId;\n\n      if (this.x) {\n        this.renderLine();\n      }\n\n      return React.createElement('div', {\n        className: 'bx--graph-container',\n        id: containerId,\n        style: {\n          position: 'relative'\n        }\n      }, React.createElement('p', {\n        className: 'bx--line-graph-empty-text'\n      }), React.createElement('svg', {\n        id: id,\n        ref: function ref(id) {\n          return _this6.id = id;\n        }\n      }), React.createElement('div', {\n        id: id + '-tooltip',\n        ref: function ref(id) {\n          return _this6.tooltipId = id;\n        }\n      }));\n    }\n  }]);\n\n  return LineGraph;\n}(Component);\n\nLineGraph.propTypes = propTypes;\nLineGraph.defaultProps = defaultProps;\nexport default LineGraph;","map":null,"metadata":{},"sourceType":"module"}