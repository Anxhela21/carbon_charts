// Functions
export var Tools;
(function (Tools) {
    function debounce(func, wait, immediate) {
        var timeout;
        return function () {
            var context = this, args = arguments;
            var later = function () {
                timeout = null;
                if (!immediate) {
                    func.apply(context, args);
                }
            };
            var callNow = immediate && !timeout;
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
            if (callNow) {
                func.apply(context, args);
            }
        };
    }
    Tools.debounce = debounce;
    function addCloseBtn(tooltip, size, color) {
        var closeBtn = tooltip.append("button");
        var classNames = "close--" + size;
        classNames = color ? " close--" + color : classNames;
        var iconHolder = document.createElement("span");
        iconHolder.innerHTML = "Close";
        closeBtn.attr("class", classNames)
            .attr("type", "button")
            .attr("aria-label", "Close");
        closeBtn.node()
            .appendChild(iconHolder);
        // TODO - Finish
        // console.log(iconHolder);
        return closeBtn;
    }
    Tools.addCloseBtn = addCloseBtn;
    function clone(obj) {
        return JSON.parse(JSON.stringify(obj));
    }
    Tools.clone = clone;
    // custom deep object merge
    Tools.merge = function (target) {
        var objects = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            objects[_i - 1] = arguments[_i];
        }
        for (var _a = 0, objects_1 = objects; _a < objects_1.length; _a++) {
            var object = objects_1[_a];
            for (var key in object) {
                if (object.hasOwnProperty(key)) {
                    // since we're dealing relatively simple objects this should work fine
                    if (object[key] && typeof object[key] === "object") {
                        if (!target[key]) {
                            target[key] = {};
                        }
                        // recursively merge into the target
                        // configs only run 3 or 4 levels deep, so no stack explosions
                        target[key] = Tools.merge(target[key], object[key]);
                    }
                    else {
                        target[key] = object[key];
                    }
                }
            }
        }
        return target;
    };
    /**************************************
     *  DOM-related operations            *
     *************************************/
    /**
     * Get width & height of an element
     *
     * @export
     * @param {any} el element to get dimensions from
     * @returns an object containing the width and height of el
     */
    function getDimensions(el) {
        return {
            width: parseFloat(el.style.width.replace("px", "") || el.offsetWidth),
            height: parseFloat(el.style.height.replace("px", "") || el.offsetHeight)
        };
    }
    Tools.getDimensions = getDimensions;
    /**
     * Returns element if it  exists, otherwise creates and returns reference to item
     * @param parent Element parent to query within
     * @param query The element to return from the DOM
     */
    function appendOrSelect(parent, query) {
        var l = query.split(".");
        var elementToAppend = l[0];
        var g = parent.select(query);
        if (g.empty()) {
            return parent.append(elementToAppend)
                .attr("class", l.slice(1).join(" "));
        }
        return g;
    }
    Tools.appendOrSelect = appendOrSelect;
    /**
     * Returns an elements's x and y translations from its computed style
     * @param {HTMLElement} element
     * @returns an object containing the x and y translations
     */
    function getTranslationValues(elementRef) {
        // returns matrix(a, b, c, d, tx, ty) of transformation values (2d transform)
        var transformMatrix = window.getComputedStyle(elementRef).getPropertyValue("transform").replace(/\s/g, "");
        var transformValues = transformMatrix.substring(transformMatrix.indexOf("(") + 1, transformMatrix.indexOf(")")).split(",");
        // if there are no translations, return { dx: 0,  dy: 0 } instead of undefined
        return {
            tx: transformValues[4] ? transformValues[4] : 0,
            ty: transformValues[5] ? transformValues[5] : 0
        };
    }
    Tools.getTranslationValues = getTranslationValues;
    /**************************************
     *  Formatting & calculations         *
     *************************************/
    /**
     * Gets x and y coordinates from a HTML transform attribute
     *
     * @export
     * @param {any} string the transform attribute string ie. transform(x,y)
     * @returns Returns an object with x and y offsets of the transform
     */
    function getTranformOffsets(string) {
        var regExp = /\(([^)]+)\)/;
        var match = regExp.exec(string)[1];
        var xyString = match.split(",");
        return {
            x: parseFloat(xyString[0]),
            y: parseFloat(xyString[1])
        };
    }
    Tools.getTranformOffsets = getTranformOffsets;
    function formatWidthHeightValues(value) {
        var stringValue = value.toString();
        // If the value provided contains any letters
        // Return it the same way
        if (stringValue.match(/[a-z]/i)) {
            return stringValue;
        }
        return stringValue + "px";
    }
    Tools.formatWidthHeightValues = formatWidthHeightValues;
    /**
     * Capitalizes first letter of a string
     *
     * @export
     * @param {any} string the string whose first letter you'd like to capitalize
     * @returns The input string with its first letter capitalized
     */
    function capitalizeFirstLetter(string) {
        return string[0].toUpperCase() + string.slice(1);
    }
    Tools.capitalizeFirstLetter = capitalizeFirstLetter;
    /**
     * Get the percentage of a datapoint compared to the entire data-set
     *
     * @export
     * @param {any} item
     * @param {any} fullData
     * @returns The percentage in the form of a string "87%"
     */
    function convertValueToPercentage(item, fullData) {
        return Math.floor(item / fullData.reduce(function (accum, val) { return accum + val.value; }, 0) * 100) + "%";
    }
    Tools.convertValueToPercentage = convertValueToPercentage;
    /**************************************
     *  Object/array related checks       *
     *************************************/
    /**
     * Get the difference between two arrays' items
     *
     * @export
     * @param {any[]} oldArray
     * @param {any[]} newArray
     * @returns The items missing in newArray from oldArray, and items added to newArray compared to oldArray
     */
    function arrayDifferences(oldArray, newArray) {
        var difference = {
            missing: [],
            added: []
        };
        oldArray.forEach(function (element) {
            if (newArray.indexOf(element) === -1) {
                difference.missing.push(element);
            }
        });
        newArray.forEach(function (element) {
            if (oldArray.indexOf(element) === -1) {
                difference.added.push(element);
            }
        });
        return difference;
    }
    Tools.arrayDifferences = arrayDifferences;
    /**
     * Lists out the duplicated keys in an array of data
     *
     * @export
     * @param {*} data - array of data
     * @returns A list of the duplicated keys in data
     */
    function getDuplicateValues(arr) {
        var values = [];
        var duplicateValues = [];
        arr.forEach(function (value) {
            if (values.indexOf(value) !== -1 && duplicateValues.indexOf(value) === -1) {
                duplicateValues.push(value);
            }
            values.push(value);
        });
        return duplicateValues;
    }
    Tools.getDuplicateValues = getDuplicateValues;
    function removeArrayDuplicates(arr) {
        // Casting to any because of the lack of typescript types
        // Set removes duplicates automatically
        var result = new Set(arr);
        // Spread operator appends all elements from result into []
        return result.slice();
    }
    Tools.removeArrayDuplicates = removeArrayDuplicates;
    // ================================================================================
    // D3 Extensions
    // ================================================================================
    /**
     * In D3, moves an element to the front of the canvas
     *
     * @export
     * @param {any} element
     * @returns The function to be used by D3 to push element to the top of the canvas
     */
    function moveToFront(element) {
        return element.each(function () {
            this.parentNode.appendChild(this);
        });
    }
    Tools.moveToFront = moveToFront;
    // ================================================================================
    // Style Helpers
    // ================================================================================
    Tools.getProperty = function (object) {
        var propPath = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            propPath[_i - 1] = arguments[_i];
        }
        var position = object;
        for (var _a = 0, propPath_1 = propPath; _a < propPath_1.length; _a++) {
            var prop = propPath_1[_a];
            if (position[prop]) {
                position = position[prop];
            }
            else {
                return null;
            }
        }
        return position;
    };
})(Tools || (Tools = {}));
//# sourceMappingURL=/home/travis/build/carbon-design-system/carbon-charts/packages/core/tools.js.map