var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
// D3 Imports
import { select } from "d3-selection";
import { scaleOrdinal } from "d3-scale";
import { pie, arc } from "d3-shape";
import { interpolate } from "d3-interpolate";
import { BaseChart } from "./base-chart";
import * as Configuration from "./configuration";
import { ChartType } from "./configuration";
import { Tools } from "./tools";
var PieChart = /** @class */ (function (_super) {
    __extends(PieChart, _super);
    function PieChart(holder, configs, type) {
        if (type === void 0) { type = ChartType.PIE; }
        var _this = _super.call(this, holder, configs) || this;
        _this.getTooltipHTML = function (d) { return _this.generateTooltipHTML(d.data.label, d.value.toLocaleString()); };
        _this.options.type = type;
        // Assign colors to each slice using their label
        _this.colorScale = scaleOrdinal(_this.options.colors);
        return _this;
    }
    // Sort data by value (descending)
    // Cap number of slices at a specific number, and group the remaining items into the label "Other"
    PieChart.prototype.dataProcessor = function (dataObject) {
        // TODO - Support multiple datasets
        if (dataObject.datasets.length > 1) {
            console.warn("Currently the Pie & Donut charts support a single dataset,\n\t\t\t\tyou appear to have more than that. Will only use your first provided dataset.");
        }
        // Check for duplicate keys in the data
        var duplicates = Tools.getDuplicateValues(dataObject.labels);
        if (duplicates.length > 0) {
            console.error(Tools.capitalizeFirstLetter(this.options.type) + " Chart - You have duplicate keys", duplicates);
        }
        // TODO - Support multiple datasets
        // let sortedData = data.datasets[0];
        var dataList = dataObject.datasets[0].data.map(function (datum, i) { return ({
            label: dataObject.labels[i],
            value: datum,
        }); });
        // Sort data by value
        var sortedData = dataList.sort(function (a, b) { return b.value - a.value; });
        // Keep a certain number of slices, and add an "Other" slice for the rest
        var stopAt = Configuration.pie.sliceLimit;
        var rest = sortedData.slice(stopAt);
        var restAccumulatedValue = rest.reduce(function (accum, item) { return accum + item.value; }, 0);
        var otherLabelIndex = sortedData.findIndex(function (dataPoint) { return dataPoint.label === "Other"; });
        if (otherLabelIndex !== -1) {
            sortedData.push(sortedData.splice(otherLabelIndex, 1)[0]);
        }
        else if (rest.length > 0) {
            sortedData = sortedData.slice(0, stopAt)
                .concat([{
                    label: Configuration.pie.label.other,
                    value: restAccumulatedValue,
                    items: rest
                }]);
        }
        return {
            // Sort labels based on the order made above
            labels: sortedData.map(function (datum, i) { return datum.label; }),
            datasets: [
                {
                    // copy all the relevant properties
                    backgroundColors: dataObject.datasets[0].backgroundColors,
                    chartType: dataObject.datasets[0].chartType,
                    label: dataObject.datasets[0].label,
                    // add our sorted data
                    data: sortedData
                }
            ]
        };
    };
    // If there isn't a chart already drawn in the container
    // This function is called and will do that
    PieChart.prototype.initialDraw = function () {
        this.setSVG();
        // Add legend
        this.addOrUpdateLegend();
        // Draw slices & labels
        this.draw();
        // Add event listeners to slices
        this.addDataPointEventListener();
    };
    PieChart.prototype.draw = function () {
        var _this = this;
        var dataList = this.displayData.datasets[0].data;
        var chartSize = this.getChartSize(this.container);
        var diameter = Math.min(chartSize.width, chartSize.height);
        var radius = diameter / 2;
        select(this.holder).select("svg")
            .attr("width", diameter + "px")
            .attr("height", diameter + "px");
        this.innerWrap
            .attr("transform", "translate(" + radius + "," + radius + ")")
            .attr("width", diameter + "px")
            .attr("height", diameter + "px")
            .attr("preserveAspectRatio", "xMinYMin");
        // Compute the correct inner & outer radius
        var marginedRadius = this.computeRadius();
        this.arc = arc()
            .innerRadius(this.options.type === "donut" ? (marginedRadius * (3 / 4)) : 2)
            .outerRadius(marginedRadius);
        this.pie = pie()
            .value(function (d) { return d.value; })
            .sort(null)
            .padAngle(0.007);
        // Draw the slices
        this.path = this.innerWrap.selectAll("path")
            .data(this.pie(dataList))
            .enter()
            .append("path")
            .attr("d", this.arc)
            .attr("fill", function (d) { return _this.getFillColor(_this.displayData.datasets[0].label, d.data.label, d.data.value); }) // Support multiple datasets
            .attr("stroke", function (d) { return _this.getStrokeColor(_this.displayData.datasets[0].label, d.data.label, d.data.value); })
            .attr("stroke-width", Configuration.pie.default.strokeWidth)
            .attr("stroke-opacity", function (d) { return _this.options.accessibility ? 1 : 0; })
            .each(function (d) { this._current = d; });
        // Draw the slice labels
        var self = this;
        this.innerWrap
            .selectAll("text.chart-label")
            .data(this.pie(dataList), function (d) { return d.data.label; })
            .enter()
            .append("text")
            .classed("chart-label", true)
            .attr("dy", Configuration.pie.label.dy)
            .style("text-anchor", "middle")
            .text(function (d) { return Tools.convertValueToPercentage(d.data.value, dataList); })
            .attr("transform", function (d) { return self.deriveTransformString(this, d, radius); });
        // Hide overlay
        this.chartOverlay.hide();
    };
    // Interpolated transitions for older data points to reflect the new data changes
    PieChart.prototype.interpolateValues = function (newData) {
        var _this = this;
        var dataList = newData.datasets[0].data;
        // Apply the new data to the slices, and interpolate them
        var self = this;
        var path = this.innerWrap.selectAll("path").data(this.pie(dataList));
        // Update slices
        path
            .transition()
            .duration(0)
            .attr("stroke", function (d) { return _this.getStrokeColor(_this.displayData.datasets[0].label, d.data.label, d.data.value); })
            .attr("stroke-width", Configuration.pie.default.strokeWidth)
            .attr("stroke-opacity", function (d) { return _this.options.accessibility ? 1 : 0; })
            .transition()
            .style("opacity", 1)
            .duration(Configuration.transitions.default.duration)
            .attr("fill", function (d) { return _this.getFillColor(_this.displayData.datasets[0].label, d.data.label, d.data.value); })
            .attrTween("d", function (a) {
            return arcTween.bind(this)(a, self.arc);
        });
        path.enter()
            .append("path")
            .attr("d", this.arc)
            .transition()
            .duration(0)
            .style("opacity", 0)
            .attr("stroke", function (d) { return _this.getStrokeColor(_this.displayData.datasets[0].label, d.data.label, d.data.value); })
            .attr("stroke-width", Configuration.pie.default.strokeWidth)
            .attr("stroke-opacity", function (d) { return _this.options.accessibility ? 1 : 0; })
            .transition()
            .duration(Configuration.transitions.default.duration)
            .attr("fill", function (d) { return _this.getFillColor(_this.displayData.datasets[0].label, d.data.label, d.data.value); })
            .style("opacity", 1)
            .attrTween("d", function (a) {
            return arcTween.bind(this)(a, self.arc);
        });
        path
            .exit()
            .attr("d", this.arc)
            .transition()
            .duration(Configuration.transitions.default.duration)
            .style("opacity", 0)
            .remove();
        // Fade out all text labels
        this.innerWrap.selectAll("text.chart-label")
            .transition()
            .duration(Configuration.transitions.default.duration / 2)
            .style("opacity", 0)
            .on("end", function (d) {
            select(this)
                .transition()
                .duration(Configuration.transitions.default.duration / 2)
                .style("opacity", 1);
        });
        // Move text labels to their new location, and fade them in again
        var radius = this.computeRadius();
        setTimeout(function () {
            var text = _this.innerWrap.selectAll("text.chart-label")
                .data(_this.pie(dataList), function (d) { return d.label; });
            text
                .enter()
                .append("text")
                .classed("chart-label", true)
                .attr("dy", Configuration.pie.label.dy)
                .style("text-anchor", "middle")
                .text(function (d) { return Tools.convertValueToPercentage(d.data.value, dataList); })
                .attr("transform", function (d) { return self.deriveTransformString(this, d, radius); })
                .style("opacity", 0)
                .transition()
                .duration(Configuration.transitions.default.duration / 2)
                .style("opacity", 1);
            text
                .style("text-anchor", "middle")
                .text(function (d) { return Tools.convertValueToPercentage(d.data.value, dataList); })
                .attr("transform", function (d) { return self.deriveTransformString(this, d, radius); })
                .transition()
                .duration(Configuration.transitions.default.duration / 2)
                .style("opacity", 1);
            text
                .exit()
                .remove();
        }, Configuration.transitions.default.duration / 2);
        // Add slice hover actions, and clear any slice borders present
        this.addDataPointEventListener();
        this.reduceOpacity();
        // Hide the overlay
        this.chartOverlay.hide();
    };
    // TODO - Possible inherits from base-chart
    PieChart.prototype.reduceOpacity = function (exception) {
        var _this = this;
        if (exception) {
            // this.innerWrap.selectAll("path").attr("fill-opacity", Configuration.charts.reduceOpacity.opacity);
            // Fade everything out except for this element
            select(exception).attr("fill-opacity", false);
            select(exception).attr("stroke-opacity", Configuration.charts.reduceOpacity.opacity);
            select(exception).attr("fill", function (d) { return _this.getFillColor(_this.displayData.datasets[0].label, d.data.label, d.data.value); });
        }
    };
    // TODO - Refactor
    PieChart.prototype.addDataPointEventListener = function () {
        var self = this;
        var accessibility = this.options.accessibility;
        this.innerWrap.selectAll("path")
            .on("click", function (d) { return self.dispatchEvent("pie-slice-onClick", d); })
            .on("mouseover", function (d) {
            var sliceElement = select(this);
            Tools.moveToFront(sliceElement);
            sliceElement.attr("stroke-width", Configuration.pie.mouseover.strokeWidth)
                .attr("stroke-opacity", Configuration.pie.mouseover.strokeOpacity)
                .attr("stroke", self.getStrokeColor(self.displayData.datasets[0].label, d.data.label, d.data.value));
            self.showTooltip(d);
            self.reduceOpacity(this);
        })
            .on("mousemove", function (d) { return self.tooltip.positionTooltip(); })
            .on("mouseout", function (d) {
            select(this)
                .attr("stroke-width", accessibility ? Configuration.pie.default.strokeWidth : Configuration.pie.mouseout.strokeWidth)
                .attr("stroke", accessibility ? self.getStrokeColor(self.displayData.datasets[0].label, d.data.label, d.data.value) : "none")
                .attr("stroke-opacity", Configuration.pie.mouseout.strokeOpacity);
            self.hideTooltip();
        });
    };
    PieChart.prototype.update = function (newData) {
        var oldData = Tools.clone(this.displayData);
        var activeLegendItems = this.getActiveLegendItems();
        // TODO - Support multiple datasets
        var newDisplayData = Object.assign({}, oldData);
        newDisplayData.datasets[0].data = oldData.datasets[0].data.filter(function (dataPoint) { return activeLegendItems.indexOf(dataPoint.label) !== -1; });
        newDisplayData.labels = newDisplayData.datasets[0].data.map(function (datum) { return datum.label; });
        this.interpolateValues(newDisplayData);
    };
    PieChart.prototype.resizeChart = function () {
        var chartSize = this.getChartSize(this.container);
        var dimensionToUseForScale = Math.min(chartSize.width, chartSize.height);
        var radius = this.computeRadius();
        // Resize the SVG
        select(this.holder).select("svg")
            .attr("width", dimensionToUseForScale + "px")
            .attr("height", dimensionToUseForScale + "px");
        this.innerWrap
            .style("transform", "translate(" + radius + "px," + radius + "px)");
        // Resize the arc
        this.arc = arc()
            .innerRadius(this.options.type === "donut" ? (radius * (3 / 4)) : 2)
            .outerRadius(radius);
        this.innerWrap.selectAll("path")
            .attr("d", this.arc);
        var self = this;
        this.innerWrap
            .selectAll("text.chart-label")
            .attr("transform", function (d) { return self.deriveTransformString(this, d, radius); });
        // Reposition the legend
        this.positionLegend();
    };
    // Helper functions
    PieChart.prototype.computeRadius = function () {
        var chartSize = this.getChartSize(this.container);
        var radius = Math.min(chartSize.width, chartSize.height) / 2;
        return radius;
    };
    /**
     * Return the css transform string to be used for the slice
     *
     * @private
     * @param {any} d - d3 data item for slice
     * @param {any} radius - computed radius of the chart
     * @returns final transform string to be applied to the <text> element
     * @memberof PieChart
     */
    PieChart.prototype.deriveTransformString = function (element, d, radius) {
        var textLength = element.getComputedTextLength();
        var textOffsetX = textLength / 2;
        var textOffsetY = parseFloat(getComputedStyle(element).fontSize) / 2;
        var marginedRadius = radius + Configuration.pie.label.margin;
        var theta = ((d.endAngle - d.startAngle) / 2) + d.startAngle;
        var xPosition = (textOffsetX + marginedRadius) * Math.sin(theta);
        var yPosition = (textOffsetY + marginedRadius) * -Math.cos(theta);
        return "translate(" + xPosition + ", " + yPosition + ")";
    };
    return PieChart;
}(BaseChart));
export { PieChart };
// d3 Tween functions
function arcTween(a, arcFunc) {
    var _this = this;
    var i = interpolate(this._current, a);
    return function (t) {
        _this._current = i(t);
        return arcFunc(_this._current);
    };
}
//# sourceMappingURL=/home/travis/build/carbon-design-system/carbon-charts/packages/core/pie-chart.js.map